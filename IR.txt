PL/0 Compiler Intermediate Representation (IR) Documentation

Overview
This document describes the Intermediate Representation (IR) generated by the PL/0 compiler's `IRGenerator`.The IR is a low-level,
assembly-like representation that serves as an abstraction layer between the high-level PL/0 source code and the target machine code.

- IR Structure

The generated IR consists of three main sections:

1. Data Section
Contains constant declarations and string literals.

2. BSS Section  
Contains uninitialized global variable declarations.

3. Text Section
Contains the executable code with labels, instructions, and procedure definitions.

- Virtual Register System

The IR uses a virtual register allocation system:
- Virtual Registers**: Named with prefix `v` followed by a counter (e.g., `v0`, `v1`, `v2`)
- Register Allocation**: Sequential allocation with automatic incrementing
- Scope**: Registers are allocated as needed during expression evaluation

- Memory Model

- Symbol Locations
The IR supports four types of symbol locations:

1. Stack Offset**: `bp-{offset}` - Local variables relative to base pointer
2. Global Label**: Direct global variable or procedure labels
3. Immediate Values**: Constants embedded directly in instructions
4. Up-level Access**: `up-{offset}-{distance}` - Access to variables in outer scopes

- Stack Frame Layout
- Base Pointer (BP)**: Points to current stack frame
- Local Variables**: Stored at `bp-{offset}` starting from offset 16
- Stack Alignment**: 16-byte aligned stack frames
- Procedure Entry**: Automatic stack space allocation

- Instruction Set

- Arithmetic Instructions

- `li rd, imm`
- Load Immediate**
- Loads an immediate value into a register
- Used for constants and literals

- `add rd, rs1, rs2`
  - Performs integer addition: `rd = rs1 + rs2`

- `sub rd, rs1, rs2`
  - Performs integer subtraction: `rd = rs1 - rs2`

- `mul rd, rs1, rs2`
  - Performs integer multiplication: `rd = rs1 * rs2`

- `div rd, rs1, rs2`
  - Performs integer division: `rd = rs1 / rs2`

- `mod rd, rs1, rs2`
  - Performs modulo operation: `rd = rs1 % rs2`

- Memory Instructions

- `ld rd, address`
  - Loads value from memory address into register
- Supports various addressing modes:
  - `ld v0, global_var` - Load from global variable
  - `ld v0, bp-8` - Load from stack offset
  - `ld v0, up-8-1` - Load from outer scope (offset 8, distance 1)

- `st address, rs`
  - Stores register value to memory address
  - Supports same addressing modes as load

- `la rd, label`
  - Loads the address of a label into register
  - Used for procedure addresses

- Comparison Instructions

- `cmp_eq rd, rs1, rs2`
- Sets `rd = 1` if `rs1 == rs2`, otherwise `rd = 0`

- `cmp_ne rd, rs1, rs2`
- Sets `rd = 1` if `rs1 != rs2`, otherwise `rd = 0`

- `cmp_lt rd, rs1, rs2`
- Sets `rd = 1` if `rs1 < rs2`, otherwise `rd = 0`

- `cmp_le rd, rs1, rs2`
- Sets `rd = 1` if `rs1 <= rs2`, otherwise `rd = 0`

- `cmp_gt rd, rs1, rs2`
- Sets `rd = 1` if `rs1 > rs2`, otherwise `rd = 0`

- `cmp_ge rd, rs1, rs2`
- Sets `rd = 1` if `rs1 >= rs2`, otherwise `rd = 0`

- `is_odd rd, rs`
- Sets `rd = 1` if `rs` is odd, otherwise `rd = 0`
- Used for PL/0's `ODD` condition

-Control Flow Instructions

- `beqz rs, label`
- Jumps to label if register value is zero
- Primary conditional branch instruction

- `jump label`
- Unconditionally jumps to the specified label

- `label:`
- Defines a jump target
- Labels are automatically generated with format `L{counter}`

- Procedure Instructions

- `proc_enter stack_size`
- Sets up procedure stack frame
- Allocates specified stack space
- Saves caller's base pointer

- `proc_exit`
- Restores caller's stack frame
- Returns control to caller

- `call label`
- Calls procedure at specified label
- Handles stack frame setup and return address

- I/O Instructions

- `read_int rd`
- Reads integer from standard input into register

- `read_char rd`
- Reads character from standard input into register

- `write_int rs`
- Writes integer from register to standard output

- `write_str "string"`
- Writes string literal to standard output

- System Instructions

- `exit code`
- Terminates program with specified exit code

- Code Generation Patterns

- Variable Access

- Global variable access
- ld v0, global_var

- Local variable access  
- ld v0, bp-16

- Outer scope access (distance 1, offset 8)
- ld v0, up-8-1


- Expression Evaluation

- Binary operation: a + b
- ld v0, a          # Load operand a
- ld v1, b          # Load operand b  
- add v2, v0, v1    # Perform addition

- Conditional Statements

- if condition then stmt
- beqz v0, L1       # Branch if false
L1:

- While Loops

- while condition do stmt
L1:
beqz v0, L2       # Branch if false
jump L1           # Continue loop
L2:

- Procedure Calls

# Call procedure
- call procedure_name

- Variable Assignment

- variable := expression
- st variable, v0

- Symbol Table Integration

The IR generator integrates closely with the symbol table to:

- Resolve Identifiers**: Map variable names to memory locations
- Type Checking**: Ensure correct usage of constants, variables, and procedures
- Scope Management**: Handle nested procedure scopes and variable access
- Memory Layout**: Assign appropriate storage locations (global, stack, immediate)

## Optimization Considerations

While this IR is designed for correctness rather than optimization, it includes several features that facilitate later optimization passes:

- Virtual Registers**: Enable register allocation optimization
- Explicit Memory Operations**: Clear distinction between computation and memory access
- Structured Control Flow**: Maintains high-level control structures
- Symbol Information**: Preserves semantic information for analysis

## Example IR Output

asm

# Constants
.const PI 3

# Global variables  
.var x
.var result

# Main program
main:
    li v0, 10         # Load immediate 10
    st x, v0          # Store to variable x
    ld v1, x          # Load variable x
    li v2, 5          # Load immediate 5
    add v3, v1, v2    # Add x + 5
    st result, v3     # Store result
    ld v4, result     # Load result
    write_int v4      # Write result
    exit 0            # Exit program

# Procedure example
factorial:
    proc_enter 16     # Enter procedure with 16-byte stack
    # ... procedure body ...
    proc_exit         # Exit procedure
